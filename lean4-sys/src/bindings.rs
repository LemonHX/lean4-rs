/* automatically generated by rust-bindgen 0.65.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_ONLY_VERS_1050: u32 = 1;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_EXTSN: &[u8; 14usize] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_VERS_1050: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __has_ptrcheck: u32 = 0;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const __DARWIN_CLK_TCK: u32 = 100;
pub const CHAR_BIT: u32 = 8;
pub const MB_LEN_MAX: u32 = 6;
pub const CLK_TCK: u32 = 100;
pub const SCHAR_MAX: u32 = 127;
pub const SCHAR_MIN: i32 = -128;
pub const UCHAR_MAX: u32 = 255;
pub const CHAR_MAX: u32 = 127;
pub const CHAR_MIN: i32 = -128;
pub const USHRT_MAX: u32 = 65535;
pub const SHRT_MAX: u32 = 32767;
pub const SHRT_MIN: i32 = -32768;
pub const UINT_MAX: u32 = 4294967295;
pub const INT_MAX: u32 = 2147483647;
pub const INT_MIN: i32 = -2147483648;
pub const ULONG_MAX: i32 = -1;
pub const LONG_MAX: u64 = 9223372036854775807;
pub const LONG_MIN: i64 = -9223372036854775808;
pub const ULLONG_MAX: i32 = -1;
pub const LLONG_MAX: u64 = 9223372036854775807;
pub const LLONG_MIN: i64 = -9223372036854775808;
pub const LONG_BIT: u32 = 64;
pub const SSIZE_MAX: u64 = 9223372036854775807;
pub const WORD_BIT: u32 = 32;
pub const SIZE_T_MAX: i32 = -1;
pub const UQUAD_MAX: i32 = -1;
pub const QUAD_MAX: u64 = 9223372036854775807;
pub const QUAD_MIN: i64 = -9223372036854775808;
pub const ARG_MAX: u32 = 1048576;
pub const CHILD_MAX: u32 = 266;
pub const GID_MAX: u32 = 2147483647;
pub const LINK_MAX: u32 = 32767;
pub const MAX_CANON: u32 = 1024;
pub const MAX_INPUT: u32 = 1024;
pub const NAME_MAX: u32 = 255;
pub const NGROUPS_MAX: u32 = 16;
pub const UID_MAX: u32 = 2147483647;
pub const OPEN_MAX: u32 = 10240;
pub const PATH_MAX: u32 = 1024;
pub const PIPE_BUF: u32 = 512;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const CHARCLASS_NAME_MAX: u32 = 14;
pub const COLL_WEIGHTS_MAX: u32 = 2;
pub const EQUIV_CLASS_MAX: u32 = 2;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 255;
pub const NZERO: u32 = 20;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_EQUIV_CLASS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_KEYS_MAX: u32 = 512;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_SS_REPL_MAX: u32 = 4;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TRACE_EVENT_NAME_MAX: u32 = 30;
pub const _POSIX_TRACE_NAME_MAX: u32 = 8;
pub const _POSIX_TRACE_SYS_MAX: u32 = 8;
pub const _POSIX_TRACE_USER_EVENT_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const OFF_MIN: i64 = -9223372036854775808;
pub const OFF_MAX: u64 = 9223372036854775807;
pub const PASS_MAX: u32 = 128;
pub const NL_ARGMAX: u32 = 9;
pub const NL_LANGMAX: u32 = 14;
pub const NL_MSGMAX: u32 = 32767;
pub const NL_NMAX: u32 = 1;
pub const NL_SETMAX: u32 = 255;
pub const NL_TEXTMAX: u32 = 2048;
pub const _XOPEN_IOV_MAX: u32 = 16;
pub const IOV_MAX: u32 = 1024;
pub const _XOPEN_NAME_MAX: u32 = 255;
pub const _XOPEN_PATH_MAX: u32 = 1024;
pub const LEAN_VERSION_MAJOR: u32 = 4;
pub const LEAN_VERSION_MINOR: u32 = 0;
pub const LEAN_VERSION_PATCH: u32 = 0;
pub const LEAN_VERSION_IS_RELEASE: u32 = 0;
pub const LEAN_SPECIAL_VERSION_DESC: &[u8; 19usize] = b"nightly-2023-06-10\0";
pub const LEAN_PACKAGE_VERSION: &[u8; 10usize] = b"NOT-FOUND\0";
pub const LEAN_IS_STAGE0: u32 = 0;
pub const LEAN_CLOSURE_MAX_ARGS: u32 = 16;
pub const LEAN_OBJECT_SIZE_DELTA: u32 = 8;
pub const LEAN_MAX_SMALL_OBJECT_SIZE: u32 = 4096;
pub const LeanMaxCtorTag: u32 = 244;
pub const LeanClosure: u32 = 245;
pub const LeanArray: u32 = 246;
pub const LeanStructArray: u32 = 247;
pub const LeanScalarArray: u32 = 248;
pub const LeanString: u32 = 249;
pub const LeanMPZ: u32 = 250;
pub const LeanThunk: u32 = 251;
pub const LeanTask: u32 = 252;
pub const LeanRef: u32 = 253;
pub const LeanExternal: u32 = 254;
pub const LeanReserved: u32 = 255;
pub const LEAN_MAX_CTOR_FIELDS: u32 = 256;
pub const LEAN_MAX_CTOR_SCALARS_SIZE: u32 = 1024;
pub const LEAN_MAX_SMALL_NAT: i32 = -1;
pub type wchar_t = ::core::ffi::c_int;
pub type max_align_t = f64;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type __int8_t = ::core::ffi::c_schar;
pub type __uint8_t = ::core::ffi::c_uchar;
pub type __int16_t = ::core::ffi::c_short;
pub type __uint16_t = ::core::ffi::c_ushort;
pub type __int32_t = ::core::ffi::c_int;
pub type __uint32_t = ::core::ffi::c_uint;
pub type __int64_t = ::core::ffi::c_longlong;
pub type __uint64_t = ::core::ffi::c_ulonglong;
pub type __darwin_intptr_t = ::core::ffi::c_long;
pub type __darwin_natural_t = ::core::ffi::c_uint;
pub type __darwin_ct_rune_t = ::core::ffi::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::core::ffi::c_char; 128usize],
    pub _mbstateL: ::core::ffi::c_longlong,
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    const UNINIT: ::core::mem::MaybeUninit<__mbstate_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__mbstate_t>(),
        128usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__mbstate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__mbstate8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__mbstate8)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._mbstateL) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(_mbstateL)
        )
    );
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::core::ffi::c_long;
pub type __darwin_size_t = ::core::ffi::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::core::ffi::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::core::ffi::c_int;
pub type __darwin_clock_t = ::core::ffi::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::core::ffi::c_long;
pub type __darwin_time_t = ::core::ffi::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::core::ffi::c_uint;
pub type __darwin_fsfilcnt_t = ::core::ffi::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::core::ffi::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::core::ffi::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
    pub __arg: *mut ::core::ffi::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    const UNINIT: ::core::mem::MaybeUninit<__darwin_pthread_handler_rec> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__darwin_pthread_handler_rec>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        ::core::mem::align_of::<__darwin_pthread_handler_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__routine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::core::ffi::c_long,
    pub __opaque: [::core::ffi::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    const UNINIT: ::core::mem::MaybeUninit<_opaque_pthread_attr_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_opaque_pthread_attr_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_opaque_pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::core::ffi::c_long,
    pub __opaque: [::core::ffi::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    const UNINIT: ::core::mem::MaybeUninit<_opaque_pthread_cond_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_opaque_pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_opaque_pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::core::ffi::c_long,
    pub __opaque: [::core::ffi::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    const UNINIT: ::core::mem::MaybeUninit<_opaque_pthread_condattr_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_opaque_pthread_condattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_opaque_pthread_condattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::core::ffi::c_long,
    pub __opaque: [::core::ffi::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    const UNINIT: ::core::mem::MaybeUninit<_opaque_pthread_mutex_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_opaque_pthread_mutex_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_opaque_pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::core::ffi::c_long,
    pub __opaque: [::core::ffi::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    const UNINIT: ::core::mem::MaybeUninit<_opaque_pthread_mutexattr_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_opaque_pthread_mutexattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_opaque_pthread_mutexattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::core::ffi::c_long,
    pub __opaque: [::core::ffi::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    const UNINIT: ::core::mem::MaybeUninit<_opaque_pthread_once_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_opaque_pthread_once_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_opaque_pthread_once_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::core::ffi::c_long,
    pub __opaque: [::core::ffi::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    const UNINIT: ::core::mem::MaybeUninit<_opaque_pthread_rwlock_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_opaque_pthread_rwlock_t>(),
        200usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_opaque_pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::core::ffi::c_long,
    pub __opaque: [::core::ffi::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    const UNINIT: ::core::mem::MaybeUninit<_opaque_pthread_rwlockattr_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_opaque_pthread_rwlockattr_t>(),
        24usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_opaque_pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::core::ffi::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::core::ffi::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    const UNINIT: ::core::mem::MaybeUninit<_opaque_pthread_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_opaque_pthread_t>(),
        8192usize,
        concat!("Size of: ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_opaque_pthread_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__cleanup_stack) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__cleanup_stack)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__opaque)
        )
    );
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::core::ffi::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type u_int8_t = ::core::ffi::c_uchar;
pub type u_int16_t = ::core::ffi::c_ushort;
pub type u_int32_t = ::core::ffi::c_uint;
pub type u_int64_t = ::core::ffi::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type intmax_t = ::core::ffi::c_long;
pub type uintmax_t = ::core::ffi::c_ulong;
extern "C" {
    pub fn lean_notify_assert(
        fileName: *const ::core::ffi::c_char,
        line: ::core::ffi::c_int,
        condition: *const ::core::ffi::c_char,
    );
}
extern "C" {
    #[link_name = "lean_is_big_object_tag_rs_extern"]
    pub fn lean_is_big_object_tag(tag: u8) -> bool;
}
pub type assertion_failed___FILE___94 = [::core::ffi::c_char; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lean_object {
    pub m_rc: ::core::ffi::c_int,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_lean_object() {
    const UNINIT: ::core::mem::MaybeUninit<lean_object> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lean_object>(),
        8usize,
        concat!("Size of: ", stringify!(lean_object))
    );
    assert_eq!(
        ::core::mem::align_of::<lean_object>(),
        4usize,
        concat!("Alignment of ", stringify!(lean_object))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).m_rc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_object),
            "::",
            stringify!(m_rc)
        )
    );
}
impl lean_object {
    #[inline]
    pub fn m_cs_sz(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_m_cs_sz(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn m_other(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_m_other(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn m_tag(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_m_tag(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        m_cs_sz: ::core::ffi::c_uint,
        m_other: ::core::ffi::c_uint,
        m_tag: ::core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let m_cs_sz: u32 = unsafe { ::core::mem::transmute(m_cs_sz) };
            m_cs_sz as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let m_other: u32 = unsafe { ::core::mem::transmute(m_other) };
            m_other as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let m_tag: u32 = unsafe { ::core::mem::transmute(m_tag) };
            m_tag as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type lean_obj_arg = *mut lean_object;
pub type b_lean_obj_arg = *mut lean_object;
pub type u_lean_obj_arg = *mut lean_object;
pub type lean_obj_res = *mut lean_object;
pub type b_lean_obj_res = *mut lean_object;
#[repr(C)]
#[derive(Debug)]
pub struct lean_ctor_object {
    pub m_header: lean_object,
    pub m_objs: __IncompleteArrayField<*mut lean_object>,
}
#[test]
fn bindgen_test_layout_lean_ctor_object() {
    const UNINIT: ::core::mem::MaybeUninit<lean_ctor_object> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lean_ctor_object>(),
        8usize,
        concat!("Size of: ", stringify!(lean_ctor_object))
    );
    assert_eq!(
        ::core::mem::align_of::<lean_ctor_object>(),
        8usize,
        concat!("Alignment of ", stringify!(lean_ctor_object))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).m_header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_ctor_object),
            "::",
            stringify!(m_header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).m_objs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_ctor_object),
            "::",
            stringify!(m_objs)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct lean_array_object {
    pub m_header: lean_object,
    pub m_size: usize,
    pub m_capacity: usize,
    pub m_data: __IncompleteArrayField<*mut lean_object>,
}
#[test]
fn bindgen_test_layout_lean_array_object() {
    const UNINIT: ::core::mem::MaybeUninit<lean_array_object> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lean_array_object>(),
        24usize,
        concat!("Size of: ", stringify!(lean_array_object))
    );
    assert_eq!(
        ::core::mem::align_of::<lean_array_object>(),
        8usize,
        concat!("Alignment of ", stringify!(lean_array_object))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).m_header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_array_object),
            "::",
            stringify!(m_header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).m_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_array_object),
            "::",
            stringify!(m_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).m_capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_array_object),
            "::",
            stringify!(m_capacity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).m_data) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_array_object),
            "::",
            stringify!(m_data)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct lean_sarray_object {
    pub m_header: lean_object,
    pub m_size: usize,
    pub m_capacity: usize,
    pub m_data: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_lean_sarray_object() {
    const UNINIT: ::core::mem::MaybeUninit<lean_sarray_object> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lean_sarray_object>(),
        24usize,
        concat!("Size of: ", stringify!(lean_sarray_object))
    );
    assert_eq!(
        ::core::mem::align_of::<lean_sarray_object>(),
        8usize,
        concat!("Alignment of ", stringify!(lean_sarray_object))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).m_header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_sarray_object),
            "::",
            stringify!(m_header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).m_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_sarray_object),
            "::",
            stringify!(m_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).m_capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_sarray_object),
            "::",
            stringify!(m_capacity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).m_data) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_sarray_object),
            "::",
            stringify!(m_data)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct lean_string_object {
    pub m_header: lean_object,
    pub m_size: usize,
    pub m_capacity: usize,
    pub m_length: usize,
    pub m_data: __IncompleteArrayField<::core::ffi::c_char>,
}
#[test]
fn bindgen_test_layout_lean_string_object() {
    const UNINIT: ::core::mem::MaybeUninit<lean_string_object> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lean_string_object>(),
        32usize,
        concat!("Size of: ", stringify!(lean_string_object))
    );
    assert_eq!(
        ::core::mem::align_of::<lean_string_object>(),
        8usize,
        concat!("Alignment of ", stringify!(lean_string_object))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).m_header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_string_object),
            "::",
            stringify!(m_header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).m_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_string_object),
            "::",
            stringify!(m_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).m_capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_string_object),
            "::",
            stringify!(m_capacity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).m_length) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_string_object),
            "::",
            stringify!(m_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).m_data) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_string_object),
            "::",
            stringify!(m_data)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct lean_closure_object {
    pub m_header: lean_object,
    pub m_fun: *mut ::core::ffi::c_void,
    pub m_arity: u16,
    pub m_num_fixed: u16,
    pub m_objs: __IncompleteArrayField<*mut lean_object>,
}
#[test]
fn bindgen_test_layout_lean_closure_object() {
    const UNINIT: ::core::mem::MaybeUninit<lean_closure_object> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lean_closure_object>(),
        24usize,
        concat!("Size of: ", stringify!(lean_closure_object))
    );
    assert_eq!(
        ::core::mem::align_of::<lean_closure_object>(),
        8usize,
        concat!("Alignment of ", stringify!(lean_closure_object))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).m_header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_closure_object),
            "::",
            stringify!(m_header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).m_fun) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_closure_object),
            "::",
            stringify!(m_fun)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).m_arity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_closure_object),
            "::",
            stringify!(m_arity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).m_num_fixed) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_closure_object),
            "::",
            stringify!(m_num_fixed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).m_objs) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_closure_object),
            "::",
            stringify!(m_objs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lean_ref_object {
    pub m_header: lean_object,
    pub m_value: *mut lean_object,
}
#[test]
fn bindgen_test_layout_lean_ref_object() {
    const UNINIT: ::core::mem::MaybeUninit<lean_ref_object> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lean_ref_object>(),
        16usize,
        concat!("Size of: ", stringify!(lean_ref_object))
    );
    assert_eq!(
        ::core::mem::align_of::<lean_ref_object>(),
        8usize,
        concat!("Alignment of ", stringify!(lean_ref_object))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).m_header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_ref_object),
            "::",
            stringify!(m_header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).m_value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_ref_object),
            "::",
            stringify!(m_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lean_thunk_object {
    pub m_header: lean_object,
    pub m_value: *mut lean_object,
    pub m_closure: *mut lean_object,
}
#[test]
fn bindgen_test_layout_lean_thunk_object() {
    const UNINIT: ::core::mem::MaybeUninit<lean_thunk_object> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lean_thunk_object>(),
        24usize,
        concat!("Size of: ", stringify!(lean_thunk_object))
    );
    assert_eq!(
        ::core::mem::align_of::<lean_thunk_object>(),
        8usize,
        concat!("Alignment of ", stringify!(lean_thunk_object))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).m_header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_thunk_object),
            "::",
            stringify!(m_header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).m_value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_thunk_object),
            "::",
            stringify!(m_value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).m_closure) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_thunk_object),
            "::",
            stringify!(m_closure)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lean_task_imp {
    pub m_closure: *mut lean_object,
    pub m_head_dep: *mut lean_task,
    pub m_next_dep: *mut lean_task,
    pub m_prio: ::core::ffi::c_uint,
    pub m_canceled: u8,
    pub m_keep_alive: u8,
    pub m_deleted: u8,
}
#[test]
fn bindgen_test_layout_lean_task_imp() {
    const UNINIT: ::core::mem::MaybeUninit<lean_task_imp> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lean_task_imp>(),
        32usize,
        concat!("Size of: ", stringify!(lean_task_imp))
    );
    assert_eq!(
        ::core::mem::align_of::<lean_task_imp>(),
        8usize,
        concat!("Alignment of ", stringify!(lean_task_imp))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).m_closure) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_task_imp),
            "::",
            stringify!(m_closure)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).m_head_dep) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_task_imp),
            "::",
            stringify!(m_head_dep)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).m_next_dep) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_task_imp),
            "::",
            stringify!(m_next_dep)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).m_prio) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_task_imp),
            "::",
            stringify!(m_prio)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).m_canceled) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_task_imp),
            "::",
            stringify!(m_canceled)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).m_keep_alive) as usize - ptr as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_task_imp),
            "::",
            stringify!(m_keep_alive)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).m_deleted) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_task_imp),
            "::",
            stringify!(m_deleted)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lean_task {
    pub m_header: lean_object,
    pub m_value: *mut lean_object,
    pub m_imp: *mut lean_task_imp,
}
#[test]
fn bindgen_test_layout_lean_task() {
    const UNINIT: ::core::mem::MaybeUninit<lean_task> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lean_task>(),
        24usize,
        concat!("Size of: ", stringify!(lean_task))
    );
    assert_eq!(
        ::core::mem::align_of::<lean_task>(),
        8usize,
        concat!("Alignment of ", stringify!(lean_task))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).m_header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_task),
            "::",
            stringify!(m_header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).m_value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_task),
            "::",
            stringify!(m_value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).m_imp) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_task),
            "::",
            stringify!(m_imp)
        )
    );
}
pub type lean_task_object = lean_task;
pub type lean_external_finalize_proc =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>;
pub type lean_external_foreach_proc = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: b_lean_obj_arg),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lean_external_class {
    pub m_finalize: lean_external_finalize_proc,
    pub m_foreach: lean_external_foreach_proc,
}
#[test]
fn bindgen_test_layout_lean_external_class() {
    const UNINIT: ::core::mem::MaybeUninit<lean_external_class> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lean_external_class>(),
        16usize,
        concat!("Size of: ", stringify!(lean_external_class))
    );
    assert_eq!(
        ::core::mem::align_of::<lean_external_class>(),
        8usize,
        concat!("Alignment of ", stringify!(lean_external_class))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).m_finalize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_external_class),
            "::",
            stringify!(m_finalize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).m_foreach) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_external_class),
            "::",
            stringify!(m_foreach)
        )
    );
}
extern "C" {
    pub fn lean_register_external_class(
        arg1: lean_external_finalize_proc,
        arg2: lean_external_foreach_proc,
    ) -> *mut lean_external_class;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lean_external_object {
    pub m_header: lean_object,
    pub m_class: *mut lean_external_class,
    pub m_data: *mut ::core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_lean_external_object() {
    const UNINIT: ::core::mem::MaybeUninit<lean_external_object> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lean_external_object>(),
        24usize,
        concat!("Size of: ", stringify!(lean_external_object))
    );
    assert_eq!(
        ::core::mem::align_of::<lean_external_object>(),
        8usize,
        concat!("Alignment of ", stringify!(lean_external_object))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).m_header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_external_object),
            "::",
            stringify!(m_header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).m_class) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_external_object),
            "::",
            stringify!(m_class)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).m_data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lean_external_object),
            "::",
            stringify!(m_data)
        )
    );
}
extern "C" {
    #[link_name = "lean_is_scalar_rs_extern"]
    pub fn lean_is_scalar(o: *mut lean_object) -> bool;
}
extern "C" {
    #[link_name = "lean_box_rs_extern"]
    pub fn lean_box(n: usize) -> *mut lean_object;
}
extern "C" {
    #[link_name = "lean_unbox_rs_extern"]
    pub fn lean_unbox(o: *mut lean_object) -> usize;
}
extern "C" {
    pub fn lean_set_exit_on_panic(flag: bool);
}
extern "C" {
    pub fn lean_set_panic_messages(flag: bool);
}
extern "C" {
    pub fn lean_panic_fn(default_val: *mut lean_object, msg: *mut lean_object) -> *mut lean_object;
}
extern "C" {
    pub fn lean_internal_panic(msg: *const ::core::ffi::c_char) -> !;
}
extern "C" {
    pub fn lean_internal_panic_out_of_memory() -> !;
}
extern "C" {
    pub fn lean_internal_panic_unreachable() -> !;
}
extern "C" {
    pub fn lean_internal_panic_rc_overflow() -> !;
}
extern "C" {
    #[link_name = "lean_align_rs_extern"]
    pub fn lean_align(v: usize, a: usize) -> usize;
}
extern "C" {
    #[link_name = "lean_get_slot_idx_rs_extern"]
    pub fn lean_get_slot_idx(sz: ::core::ffi::c_uint) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn lean_alloc_small(
        sz: ::core::ffi::c_uint,
        slot_idx: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn lean_free_small(p: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn lean_small_mem_size(p: *mut ::core::ffi::c_void) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn lean_inc_heartbeat();
}
extern "C" {
    pub fn malloc(arg1: ::core::ffi::c_ulong) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[link_name = "lean_alloc_small_object_rs_extern"]
    pub fn lean_alloc_small_object(sz: ::core::ffi::c_uint) -> *mut lean_object;
}
extern "C" {
    #[link_name = "lean_alloc_ctor_memory_rs_extern"]
    pub fn lean_alloc_ctor_memory(sz: ::core::ffi::c_uint) -> *mut lean_object;
}
extern "C" {
    #[link_name = "lean_small_object_size_rs_extern"]
    pub fn lean_small_object_size(o: *mut lean_object) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn free(arg1: *mut ::core::ffi::c_void);
}
extern "C" {
    #[link_name = "lean_free_small_object_rs_extern"]
    pub fn lean_free_small_object(o: *mut lean_object);
}
extern "C" {
    pub fn lean_alloc_object(sz: usize) -> *mut lean_object;
}
extern "C" {
    pub fn lean_free_object(o: *mut lean_object);
}
extern "C" {
    #[link_name = "lean_ptr_tag_rs_extern"]
    pub fn lean_ptr_tag(o: *mut lean_object) -> u8;
}
extern "C" {
    #[link_name = "lean_ptr_other_rs_extern"]
    pub fn lean_ptr_other(o: *mut lean_object) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn lean_object_byte_size(o: *mut lean_object) -> usize;
}
extern "C" {
    #[link_name = "lean_is_mt_rs_extern"]
    pub fn lean_is_mt(o: *mut lean_object) -> bool;
}
extern "C" {
    #[link_name = "lean_is_st_rs_extern"]
    pub fn lean_is_st(o: *mut lean_object) -> bool;
}
extern "C" {
    #[link_name = "lean_is_persistent_rs_extern"]
    pub fn lean_is_persistent(o: *mut lean_object) -> bool;
}
extern "C" {
    #[link_name = "lean_has_rc_rs_extern"]
    pub fn lean_has_rc(o: *mut lean_object) -> bool;
}
extern "C" {
    #[link_name = "lean_get_rc_mt_addr_rs_extern"]
    pub fn lean_get_rc_mt_addr(o: *mut lean_object) -> *mut ::core::ffi::c_int;
}
extern "C" {
    pub fn lean_inc_ref_cold(o: *mut lean_object);
}
extern "C" {
    pub fn lean_inc_ref_n_cold(o: *mut lean_object, n: ::core::ffi::c_uint);
}
extern "C" {
    #[link_name = "lean_inc_ref_rs_extern"]
    pub fn lean_inc_ref(o: *mut lean_object);
}
extern "C" {
    #[link_name = "lean_inc_ref_n_rs_extern"]
    pub fn lean_inc_ref_n(o: *mut lean_object, n: usize);
}
extern "C" {
    pub fn lean_dec_ref_cold(o: *mut lean_object);
}
extern "C" {
    #[link_name = "lean_dec_ref_rs_extern"]
    pub fn lean_dec_ref(o: *mut lean_object);
}
extern "C" {
    #[link_name = "lean_inc_rs_extern"]
    pub fn lean_inc(o: *mut lean_object);
}
extern "C" {
    #[link_name = "lean_inc_n_rs_extern"]
    pub fn lean_inc_n(o: *mut lean_object, n: usize);
}
extern "C" {
    #[link_name = "lean_dec_rs_extern"]
    pub fn lean_dec(o: *mut lean_object);
}
extern "C" {
    pub fn lean_dealloc(o: *mut lean_object);
}
extern "C" {
    #[link_name = "lean_is_ctor_rs_extern"]
    pub fn lean_is_ctor(o: *mut lean_object) -> bool;
}
extern "C" {
    #[link_name = "lean_is_closure_rs_extern"]
    pub fn lean_is_closure(o: *mut lean_object) -> bool;
}
extern "C" {
    #[link_name = "lean_is_array_rs_extern"]
    pub fn lean_is_array(o: *mut lean_object) -> bool;
}
extern "C" {
    #[link_name = "lean_is_sarray_rs_extern"]
    pub fn lean_is_sarray(o: *mut lean_object) -> bool;
}
extern "C" {
    #[link_name = "lean_is_string_rs_extern"]
    pub fn lean_is_string(o: *mut lean_object) -> bool;
}
extern "C" {
    #[link_name = "lean_is_mpz_rs_extern"]
    pub fn lean_is_mpz(o: *mut lean_object) -> bool;
}
extern "C" {
    #[link_name = "lean_is_thunk_rs_extern"]
    pub fn lean_is_thunk(o: *mut lean_object) -> bool;
}
extern "C" {
    #[link_name = "lean_is_task_rs_extern"]
    pub fn lean_is_task(o: *mut lean_object) -> bool;
}
extern "C" {
    #[link_name = "lean_is_external_rs_extern"]
    pub fn lean_is_external(o: *mut lean_object) -> bool;
}
extern "C" {
    #[link_name = "lean_is_ref_rs_extern"]
    pub fn lean_is_ref(o: *mut lean_object) -> bool;
}
extern "C" {
    #[link_name = "lean_obj_tag_rs_extern"]
    pub fn lean_obj_tag(o: *mut lean_object) -> ::core::ffi::c_uint;
}
extern "C" {
    #[link_name = "lean_to_ctor_rs_extern"]
    pub fn lean_to_ctor(o: *mut lean_object) -> *mut lean_ctor_object;
}
extern "C" {
    #[link_name = "lean_to_closure_rs_extern"]
    pub fn lean_to_closure(o: *mut lean_object) -> *mut lean_closure_object;
}
extern "C" {
    #[link_name = "lean_to_array_rs_extern"]
    pub fn lean_to_array(o: *mut lean_object) -> *mut lean_array_object;
}
extern "C" {
    #[link_name = "lean_to_sarray_rs_extern"]
    pub fn lean_to_sarray(o: *mut lean_object) -> *mut lean_sarray_object;
}
extern "C" {
    #[link_name = "lean_to_string_rs_extern"]
    pub fn lean_to_string(o: *mut lean_object) -> *mut lean_string_object;
}
extern "C" {
    #[link_name = "lean_to_thunk_rs_extern"]
    pub fn lean_to_thunk(o: *mut lean_object) -> *mut lean_thunk_object;
}
extern "C" {
    #[link_name = "lean_to_task_rs_extern"]
    pub fn lean_to_task(o: *mut lean_object) -> *mut lean_task_object;
}
extern "C" {
    #[link_name = "lean_to_ref_rs_extern"]
    pub fn lean_to_ref(o: *mut lean_object) -> *mut lean_ref_object;
}
extern "C" {
    #[link_name = "lean_to_external_rs_extern"]
    pub fn lean_to_external(o: *mut lean_object) -> *mut lean_external_object;
}
extern "C" {
    #[link_name = "lean_is_exclusive_rs_extern"]
    pub fn lean_is_exclusive(o: *mut lean_object) -> bool;
}
extern "C" {
    #[link_name = "lean_is_shared_rs_extern"]
    pub fn lean_is_shared(o: *mut lean_object) -> bool;
}
extern "C" {
    pub fn lean_mark_mt(o: *mut lean_object);
}
extern "C" {
    pub fn lean_mark_persistent(o: *mut lean_object);
}
extern "C" {
    #[link_name = "lean_set_st_header_rs_extern"]
    pub fn lean_set_st_header(
        o: *mut lean_object,
        tag: ::core::ffi::c_uint,
        other: ::core::ffi::c_uint,
    );
}
extern "C" {
    #[link_name = "lean_set_non_heap_header_rs_extern"]
    pub fn lean_set_non_heap_header(
        o: *mut lean_object,
        sz: usize,
        tag: ::core::ffi::c_uint,
        other: ::core::ffi::c_uint,
    );
}
extern "C" {
    #[link_name = "lean_set_non_heap_header_for_big_rs_extern"]
    pub fn lean_set_non_heap_header_for_big(
        o: *mut lean_object,
        tag: ::core::ffi::c_uint,
        other: ::core::ffi::c_uint,
    );
}
extern "C" {
    #[link_name = "lean_ctor_num_objs_rs_extern"]
    pub fn lean_ctor_num_objs(o: *mut lean_object) -> ::core::ffi::c_uint;
}
extern "C" {
    #[link_name = "lean_ctor_obj_cptr_rs_extern"]
    pub fn lean_ctor_obj_cptr(o: *mut lean_object) -> *mut *mut lean_object;
}
extern "C" {
    #[link_name = "lean_ctor_scalar_cptr_rs_extern"]
    pub fn lean_ctor_scalar_cptr(o: *mut lean_object) -> *mut u8;
}
extern "C" {
    #[link_name = "lean_alloc_ctor_rs_extern"]
    pub fn lean_alloc_ctor(
        tag: ::core::ffi::c_uint,
        num_objs: ::core::ffi::c_uint,
        scalar_sz: ::core::ffi::c_uint,
    ) -> *mut lean_object;
}
extern "C" {
    #[link_name = "lean_ctor_get_rs_extern"]
    pub fn lean_ctor_get(o: b_lean_obj_arg, i: ::core::ffi::c_uint) -> b_lean_obj_res;
}
extern "C" {
    #[link_name = "lean_ctor_set_rs_extern"]
    pub fn lean_ctor_set(o: b_lean_obj_arg, i: ::core::ffi::c_uint, v: lean_obj_arg);
}
extern "C" {
    #[link_name = "lean_ctor_set_tag_rs_extern"]
    pub fn lean_ctor_set_tag(o: b_lean_obj_arg, new_tag: u8);
}
extern "C" {
    #[link_name = "lean_ctor_release_rs_extern"]
    pub fn lean_ctor_release(o: b_lean_obj_arg, i: ::core::ffi::c_uint);
}
extern "C" {
    #[link_name = "lean_ctor_get_usize_rs_extern"]
    pub fn lean_ctor_get_usize(o: b_lean_obj_arg, i: ::core::ffi::c_uint) -> usize;
}
extern "C" {
    #[link_name = "lean_ctor_get_uint8_rs_extern"]
    pub fn lean_ctor_get_uint8(o: b_lean_obj_arg, offset: ::core::ffi::c_uint) -> u8;
}
extern "C" {
    #[link_name = "lean_ctor_get_uint16_rs_extern"]
    pub fn lean_ctor_get_uint16(o: b_lean_obj_arg, offset: ::core::ffi::c_uint) -> u16;
}
extern "C" {
    #[link_name = "lean_ctor_get_uint32_rs_extern"]
    pub fn lean_ctor_get_uint32(o: b_lean_obj_arg, offset: ::core::ffi::c_uint) -> u32;
}
extern "C" {
    #[link_name = "lean_ctor_get_uint64_rs_extern"]
    pub fn lean_ctor_get_uint64(o: b_lean_obj_arg, offset: ::core::ffi::c_uint) -> u64;
}
extern "C" {
    #[link_name = "lean_ctor_get_float_rs_extern"]
    pub fn lean_ctor_get_float(o: b_lean_obj_arg, offset: ::core::ffi::c_uint) -> f64;
}
extern "C" {
    #[link_name = "lean_ctor_set_usize_rs_extern"]
    pub fn lean_ctor_set_usize(o: b_lean_obj_arg, i: ::core::ffi::c_uint, v: usize);
}
extern "C" {
    #[link_name = "lean_ctor_set_uint8_rs_extern"]
    pub fn lean_ctor_set_uint8(o: b_lean_obj_arg, offset: ::core::ffi::c_uint, v: u8);
}
extern "C" {
    #[link_name = "lean_ctor_set_uint16_rs_extern"]
    pub fn lean_ctor_set_uint16(o: b_lean_obj_arg, offset: ::core::ffi::c_uint, v: u16);
}
extern "C" {
    #[link_name = "lean_ctor_set_uint32_rs_extern"]
    pub fn lean_ctor_set_uint32(o: b_lean_obj_arg, offset: ::core::ffi::c_uint, v: u32);
}
extern "C" {
    #[link_name = "lean_ctor_set_uint64_rs_extern"]
    pub fn lean_ctor_set_uint64(o: b_lean_obj_arg, offset: ::core::ffi::c_uint, v: u64);
}
extern "C" {
    #[link_name = "lean_ctor_set_float_rs_extern"]
    pub fn lean_ctor_set_float(o: b_lean_obj_arg, offset: ::core::ffi::c_uint, v: f64);
}
extern "C" {
    #[link_name = "lean_closure_fun_rs_extern"]
    pub fn lean_closure_fun(o: *mut lean_object) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[link_name = "lean_closure_arity_rs_extern"]
    pub fn lean_closure_arity(o: *mut lean_object) -> ::core::ffi::c_uint;
}
extern "C" {
    #[link_name = "lean_closure_num_fixed_rs_extern"]
    pub fn lean_closure_num_fixed(o: *mut lean_object) -> ::core::ffi::c_uint;
}
extern "C" {
    #[link_name = "lean_closure_arg_cptr_rs_extern"]
    pub fn lean_closure_arg_cptr(o: *mut lean_object) -> *mut *mut lean_object;
}
extern "C" {
    #[link_name = "lean_alloc_closure_rs_extern"]
    pub fn lean_alloc_closure(
        fun: *mut ::core::ffi::c_void,
        arity: ::core::ffi::c_uint,
        num_fixed: ::core::ffi::c_uint,
    ) -> lean_obj_res;
}
extern "C" {
    #[link_name = "lean_closure_get_rs_extern"]
    pub fn lean_closure_get(o: b_lean_obj_arg, i: ::core::ffi::c_uint) -> b_lean_obj_res;
}
extern "C" {
    #[link_name = "lean_closure_set_rs_extern"]
    pub fn lean_closure_set(o: u_lean_obj_arg, i: ::core::ffi::c_uint, a: lean_obj_arg);
}
extern "C" {
    pub fn lean_apply_1(f: *mut lean_object, a1: *mut lean_object) -> *mut lean_object;
}
extern "C" {
    pub fn lean_apply_2(
        f: *mut lean_object,
        a1: *mut lean_object,
        a2: *mut lean_object,
    ) -> *mut lean_object;
}
extern "C" {
    pub fn lean_apply_3(
        f: *mut lean_object,
        a1: *mut lean_object,
        a2: *mut lean_object,
        a3: *mut lean_object,
    ) -> *mut lean_object;
}
extern "C" {
    pub fn lean_apply_4(
        f: *mut lean_object,
        a1: *mut lean_object,
        a2: *mut lean_object,
        a3: *mut lean_object,
        a4: *mut lean_object,
    ) -> *mut lean_object;
}
extern "C" {
    pub fn lean_apply_5(
        f: *mut lean_object,
        a1: *mut lean_object,
        a2: *mut lean_object,
        a3: *mut lean_object,
        a4: *mut lean_object,
        a5: *mut lean_object,
    ) -> *mut lean_object;
}
extern "C" {
    pub fn lean_apply_6(
        f: *mut lean_object,
        a1: *mut lean_object,
        a2: *mut lean_object,
        a3: *mut lean_object,
        a4: *mut lean_object,
        a5: *mut lean_object,
        a6: *mut lean_object,
    ) -> *mut lean_object;
}
extern "C" {
    pub fn lean_apply_7(
        f: *mut lean_object,
        a1: *mut lean_object,
        a2: *mut lean_object,
        a3: *mut lean_object,
        a4: *mut lean_object,
        a5: *mut lean_object,
        a6: *mut lean_object,
        a7: *mut lean_object,
    ) -> *mut lean_object;
}
extern "C" {
    pub fn lean_apply_8(
        f: *mut lean_object,
        a1: *mut lean_object,
        a2: *mut lean_object,
        a3: *mut lean_object,
        a4: *mut lean_object,
        a5: *mut lean_object,
        a6: *mut lean_object,
        a7: *mut lean_object,
        a8: *mut lean_object,
    ) -> *mut lean_object;
}
extern "C" {
    pub fn lean_apply_9(
        f: *mut lean_object,
        a1: *mut lean_object,
        a2: *mut lean_object,
        a3: *mut lean_object,
        a4: *mut lean_object,
        a5: *mut lean_object,
        a6: *mut lean_object,
        a7: *mut lean_object,
        a8: *mut lean_object,
        a9: *mut lean_object,
    ) -> *mut lean_object;
}
extern "C" {
    pub fn lean_apply_10(
        f: *mut lean_object,
        a1: *mut lean_object,
        a2: *mut lean_object,
        a3: *mut lean_object,
        a4: *mut lean_object,
        a5: *mut lean_object,
        a6: *mut lean_object,
        a7: *mut lean_object,
        a8: *mut lean_object,
        a9: *mut lean_object,
        a10: *mut lean_object,
    ) -> *mut lean_object;
}
extern "C" {
    pub fn lean_apply_11(
        f: *mut lean_object,
        a1: *mut lean_object,
        a2: *mut lean_object,
        a3: *mut lean_object,
        a4: *mut lean_object,
        a5: *mut lean_object,
        a6: *mut lean_object,
        a7: *mut lean_object,
        a8: *mut lean_object,
        a9: *mut lean_object,
        a10: *mut lean_object,
        a11: *mut lean_object,
    ) -> *mut lean_object;
}
extern "C" {
    pub fn lean_apply_12(
        f: *mut lean_object,
        a1: *mut lean_object,
        a2: *mut lean_object,
        a3: *mut lean_object,
        a4: *mut lean_object,
        a5: *mut lean_object,
        a6: *mut lean_object,
        a7: *mut lean_object,
        a8: *mut lean_object,
        a9: *mut lean_object,
        a10: *mut lean_object,
        a11: *mut lean_object,
        a12: *mut lean_object,
    ) -> *mut lean_object;
}
extern "C" {
    pub fn lean_apply_13(
        f: *mut lean_object,
        a1: *mut lean_object,
        a2: *mut lean_object,
        a3: *mut lean_object,
        a4: *mut lean_object,
        a5: *mut lean_object,
        a6: *mut lean_object,
        a7: *mut lean_object,
        a8: *mut lean_object,
        a9: *mut lean_object,
        a10: *mut lean_object,
        a11: *mut lean_object,
        a12: *mut lean_object,
        a13: *mut lean_object,
    ) -> *mut lean_object;
}
extern "C" {
    pub fn lean_apply_14(
        f: *mut lean_object,
        a1: *mut lean_object,
        a2: *mut lean_object,
        a3: *mut lean_object,
        a4: *mut lean_object,
        a5: *mut lean_object,
        a6: *mut lean_object,
        a7: *mut lean_object,
        a8: *mut lean_object,
        a9: *mut lean_object,
        a10: *mut lean_object,
        a11: *mut lean_object,
        a12: *mut lean_object,
        a13: *mut lean_object,
        a14: *mut lean_object,
    ) -> *mut lean_object;
}
extern "C" {
    pub fn lean_apply_15(
        f: *mut lean_object,
        a1: *mut lean_object,
        a2: *mut lean_object,
        a3: *mut lean_object,
        a4: *mut lean_object,
        a5: *mut lean_object,
        a6: *mut lean_object,
        a7: *mut lean_object,
        a8: *mut lean_object,
        a9: *mut lean_object,
        a10: *mut lean_object,
        a11: *mut lean_object,
        a12: *mut lean_object,
        a13: *mut lean_object,
        a14: *mut lean_object,
        a15: *mut lean_object,
    ) -> *mut lean_object;
}
extern "C" {
    pub fn lean_apply_16(
        f: *mut lean_object,
        a1: *mut lean_object,
        a2: *mut lean_object,
        a3: *mut lean_object,
        a4: *mut lean_object,
        a5: *mut lean_object,
        a6: *mut lean_object,
        a7: *mut lean_object,
        a8: *mut lean_object,
        a9: *mut lean_object,
        a10: *mut lean_object,
        a11: *mut lean_object,
        a12: *mut lean_object,
        a13: *mut lean_object,
        a14: *mut lean_object,
        a15: *mut lean_object,
        a16: *mut lean_object,
    ) -> *mut lean_object;
}
extern "C" {
    pub fn lean_apply_n(
        f: *mut lean_object,
        n: ::core::ffi::c_uint,
        args: *mut *mut lean_object,
    ) -> *mut lean_object;
}
extern "C" {
    pub fn lean_apply_m(
        f: *mut lean_object,
        n: ::core::ffi::c_uint,
        args: *mut *mut lean_object,
    ) -> *mut lean_object;
}
extern "C" {
    #[link_name = "lean_alloc_array_rs_extern"]
    pub fn lean_alloc_array(size: usize, capacity: usize) -> lean_obj_res;
}
extern "C" {
    #[link_name = "lean_array_size_rs_extern"]
    pub fn lean_array_size(o: b_lean_obj_arg) -> usize;
}
extern "C" {
    #[link_name = "lean_array_capacity_rs_extern"]
    pub fn lean_array_capacity(o: b_lean_obj_arg) -> usize;
}
extern "C" {
    #[link_name = "lean_array_byte_size_rs_extern"]
    pub fn lean_array_byte_size(o: *mut lean_object) -> usize;
}
extern "C" {
    #[link_name = "lean_array_cptr_rs_extern"]
    pub fn lean_array_cptr(o: *mut lean_object) -> *mut *mut lean_object;
}
extern "C" {
    #[link_name = "lean_array_set_size_rs_extern"]
    pub fn lean_array_set_size(o: u_lean_obj_arg, sz: usize);
}
extern "C" {
    #[link_name = "lean_array_get_core_rs_extern"]
    pub fn lean_array_get_core(o: b_lean_obj_arg, i: usize) -> b_lean_obj_res;
}
extern "C" {
    #[link_name = "lean_array_set_core_rs_extern"]
    pub fn lean_array_set_core(o: u_lean_obj_arg, i: usize, v: lean_obj_arg);
}
extern "C" {
    pub fn lean_array_mk(l: lean_obj_arg) -> *mut lean_object;
}
extern "C" {
    pub fn lean_array_data(a: lean_obj_arg) -> *mut lean_object;
}
extern "C" {
    #[link_name = "lean_array_sz_rs_extern"]
    pub fn lean_array_sz(a: lean_obj_arg) -> *mut lean_object;
}
extern "C" {
    #[link_name = "lean_array_get_size_rs_extern"]
    pub fn lean_array_get_size(a: b_lean_obj_arg) -> *mut lean_object;
}
extern "C" {
    #[link_name = "lean_mk_empty_array_rs_extern"]
    pub fn lean_mk_empty_array() -> *mut lean_object;
}
extern "C" {
    #[link_name = "lean_mk_empty_array_with_capacity_rs_extern"]
    pub fn lean_mk_empty_array_with_capacity(capacity: b_lean_obj_arg) -> *mut lean_object;
}
extern "C" {
    #[link_name = "lean_array_uget_rs_extern"]
    pub fn lean_array_uget(a: b_lean_obj_arg, i: usize) -> *mut lean_object;
}
extern "C" {
    #[link_name = "lean_array_fget_rs_extern"]
    pub fn lean_array_fget(a: b_lean_obj_arg, i: b_lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_array_get_panic(def_val: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    #[link_name = "lean_array_get_rs_extern"]
    pub fn lean_array_get(
        def_val: lean_obj_arg,
        a: b_lean_obj_arg,
        i: b_lean_obj_arg,
    ) -> *mut lean_object;
}
extern "C" {
    pub fn lean_copy_expand_array(a: lean_obj_arg, expand: bool) -> lean_obj_res;
}
extern "C" {
    #[link_name = "lean_copy_array_rs_extern"]
    pub fn lean_copy_array(a: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    #[link_name = "lean_ensure_exclusive_array_rs_extern"]
    pub fn lean_ensure_exclusive_array(a: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    #[link_name = "lean_array_uset_rs_extern"]
    pub fn lean_array_uset(a: lean_obj_arg, i: usize, v: lean_obj_arg) -> *mut lean_object;
}
extern "C" {
    #[link_name = "lean_array_fset_rs_extern"]
    pub fn lean_array_fset(a: lean_obj_arg, i: b_lean_obj_arg, v: lean_obj_arg)
        -> *mut lean_object;
}
extern "C" {
    pub fn lean_array_set_panic(a: lean_obj_arg, v: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    #[link_name = "lean_array_set_rs_extern"]
    pub fn lean_array_set(a: lean_obj_arg, i: b_lean_obj_arg, v: lean_obj_arg) -> *mut lean_object;
}
extern "C" {
    #[link_name = "lean_array_pop_rs_extern"]
    pub fn lean_array_pop(a: lean_obj_arg) -> *mut lean_object;
}
extern "C" {
    #[link_name = "lean_array_uswap_rs_extern"]
    pub fn lean_array_uswap(a: lean_obj_arg, i: usize, j: usize) -> *mut lean_object;
}
extern "C" {
    #[link_name = "lean_array_fswap_rs_extern"]
    pub fn lean_array_fswap(
        a: lean_obj_arg,
        i: b_lean_obj_arg,
        j: b_lean_obj_arg,
    ) -> *mut lean_object;
}
extern "C" {
    #[link_name = "lean_array_swap_rs_extern"]
    pub fn lean_array_swap(
        a: lean_obj_arg,
        i: b_lean_obj_arg,
        j: b_lean_obj_arg,
    ) -> *mut lean_object;
}
extern "C" {
    pub fn lean_array_push(a: lean_obj_arg, v: lean_obj_arg) -> *mut lean_object;
}
extern "C" {
    pub fn lean_mk_array(n: lean_obj_arg, v: lean_obj_arg) -> *mut lean_object;
}
extern "C" {
    #[link_name = "lean_alloc_sarray_rs_extern"]
    pub fn lean_alloc_sarray(
        elem_size: ::core::ffi::c_uint,
        size: usize,
        capacity: usize,
    ) -> lean_obj_res;
}
extern "C" {
    #[link_name = "lean_sarray_elem_size_rs_extern"]
    pub fn lean_sarray_elem_size(o: *mut lean_object) -> ::core::ffi::c_uint;
}
extern "C" {
    #[link_name = "lean_sarray_capacity_rs_extern"]
    pub fn lean_sarray_capacity(o: *mut lean_object) -> usize;
}
extern "C" {
    #[link_name = "lean_sarray_byte_size_rs_extern"]
    pub fn lean_sarray_byte_size(o: *mut lean_object) -> usize;
}
extern "C" {
    #[link_name = "lean_sarray_size_rs_extern"]
    pub fn lean_sarray_size(o: b_lean_obj_arg) -> usize;
}
extern "C" {
    #[link_name = "lean_sarray_set_size_rs_extern"]
    pub fn lean_sarray_set_size(o: u_lean_obj_arg, sz: usize);
}
extern "C" {
    #[link_name = "lean_sarray_cptr_rs_extern"]
    pub fn lean_sarray_cptr(o: *mut lean_object) -> *mut u8;
}
extern "C" {
    pub fn lean_byte_array_mk(a: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_byte_array_data(a: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_copy_byte_array(a: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_byte_array_hash(a: b_lean_obj_arg) -> u64;
}
extern "C" {
    #[link_name = "lean_mk_empty_byte_array_rs_extern"]
    pub fn lean_mk_empty_byte_array(capacity: b_lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    #[link_name = "lean_byte_array_size_rs_extern"]
    pub fn lean_byte_array_size(a: b_lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    #[link_name = "lean_byte_array_uget_rs_extern"]
    pub fn lean_byte_array_uget(a: b_lean_obj_arg, i: usize) -> u8;
}
extern "C" {
    #[link_name = "lean_byte_array_get_rs_extern"]
    pub fn lean_byte_array_get(a: b_lean_obj_arg, i: b_lean_obj_arg) -> u8;
}
extern "C" {
    #[link_name = "lean_byte_array_fget_rs_extern"]
    pub fn lean_byte_array_fget(a: b_lean_obj_arg, i: b_lean_obj_arg) -> u8;
}
extern "C" {
    pub fn lean_byte_array_push(a: lean_obj_arg, b: u8) -> lean_obj_res;
}
extern "C" {
    #[link_name = "lean_byte_array_uset_rs_extern"]
    pub fn lean_byte_array_uset(a: lean_obj_arg, i: usize, v: u8) -> *mut lean_object;
}
extern "C" {
    #[link_name = "lean_byte_array_set_rs_extern"]
    pub fn lean_byte_array_set(a: lean_obj_arg, i: b_lean_obj_arg, b: u8) -> lean_obj_res;
}
extern "C" {
    #[link_name = "lean_byte_array_fset_rs_extern"]
    pub fn lean_byte_array_fset(a: lean_obj_arg, i: b_lean_obj_arg, b: u8) -> lean_obj_res;
}
extern "C" {
    pub fn lean_float_array_mk(a: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_float_array_data(a: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_copy_float_array(a: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    #[link_name = "lean_mk_empty_float_array_rs_extern"]
    pub fn lean_mk_empty_float_array(capacity: b_lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    #[link_name = "lean_float_array_size_rs_extern"]
    pub fn lean_float_array_size(a: b_lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    #[link_name = "lean_float_array_cptr_rs_extern"]
    pub fn lean_float_array_cptr(a: b_lean_obj_arg) -> *mut f64;
}
extern "C" {
    #[link_name = "lean_float_array_uget_rs_extern"]
    pub fn lean_float_array_uget(a: b_lean_obj_arg, i: usize) -> f64;
}
extern "C" {
    #[link_name = "lean_float_array_fget_rs_extern"]
    pub fn lean_float_array_fget(a: b_lean_obj_arg, i: b_lean_obj_arg) -> f64;
}
extern "C" {
    #[link_name = "lean_float_array_get_rs_extern"]
    pub fn lean_float_array_get(a: b_lean_obj_arg, i: b_lean_obj_arg) -> f64;
}
extern "C" {
    pub fn lean_float_array_push(a: lean_obj_arg, d: f64) -> lean_obj_res;
}
extern "C" {
    #[link_name = "lean_float_array_uset_rs_extern"]
    pub fn lean_float_array_uset(a: lean_obj_arg, i: usize, d: f64) -> lean_obj_res;
}
extern "C" {
    #[link_name = "lean_float_array_fset_rs_extern"]
    pub fn lean_float_array_fset(a: lean_obj_arg, i: b_lean_obj_arg, d: f64) -> lean_obj_res;
}
extern "C" {
    #[link_name = "lean_float_array_set_rs_extern"]
    pub fn lean_float_array_set(a: lean_obj_arg, i: b_lean_obj_arg, d: f64) -> lean_obj_res;
}
extern "C" {
    #[link_name = "lean_alloc_string_rs_extern"]
    pub fn lean_alloc_string(size: usize, capacity: usize, len: usize) -> lean_obj_res;
}
extern "C" {
    pub fn lean_utf8_strlen(str_: *const ::core::ffi::c_char) -> usize;
}
extern "C" {
    pub fn lean_utf8_n_strlen(str_: *const ::core::ffi::c_char, n: usize) -> usize;
}
extern "C" {
    #[link_name = "lean_string_capacity_rs_extern"]
    pub fn lean_string_capacity(o: *mut lean_object) -> usize;
}
extern "C" {
    #[link_name = "lean_string_byte_size_rs_extern"]
    pub fn lean_string_byte_size(o: *mut lean_object) -> usize;
}
extern "C" {
    #[link_name = "lean_char_default_value_rs_extern"]
    pub fn lean_char_default_value() -> u32;
}
extern "C" {
    pub fn lean_mk_string_from_bytes(s: *const ::core::ffi::c_char, sz: usize) -> lean_obj_res;
}
extern "C" {
    pub fn lean_mk_string(s: *const ::core::ffi::c_char) -> lean_obj_res;
}
extern "C" {
    #[link_name = "lean_string_cstr_rs_extern"]
    pub fn lean_string_cstr(o: b_lean_obj_arg) -> *const ::core::ffi::c_char;
}
extern "C" {
    #[link_name = "lean_string_size_rs_extern"]
    pub fn lean_string_size(o: b_lean_obj_arg) -> usize;
}
extern "C" {
    #[link_name = "lean_string_len_rs_extern"]
    pub fn lean_string_len(o: b_lean_obj_arg) -> usize;
}
extern "C" {
    pub fn lean_string_push(s: lean_obj_arg, c: u32) -> lean_obj_res;
}
extern "C" {
    pub fn lean_string_append(s1: lean_obj_arg, s2: b_lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    #[link_name = "lean_string_length_rs_extern"]
    pub fn lean_string_length(s: b_lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_string_mk(cs: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_string_data(s: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_string_utf8_get(s: b_lean_obj_arg, i: b_lean_obj_arg) -> u32;
}
extern "C" {
    pub fn lean_string_utf8_get_fast_cold(
        str_: *const ::core::ffi::c_char,
        i: usize,
        size: usize,
        c: ::core::ffi::c_uchar,
    ) -> u32;
}
extern "C" {
    #[link_name = "lean_string_utf8_get_fast_rs_extern"]
    pub fn lean_string_utf8_get_fast(s: b_lean_obj_arg, i: b_lean_obj_arg) -> u32;
}
extern "C" {
    pub fn lean_string_utf8_next(s: b_lean_obj_arg, i: b_lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_string_utf8_next_fast_cold(i: usize, c: ::core::ffi::c_uchar) -> lean_obj_res;
}
extern "C" {
    #[link_name = "lean_string_utf8_next_fast_rs_extern"]
    pub fn lean_string_utf8_next_fast(s: b_lean_obj_arg, i: b_lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_string_utf8_prev(s: b_lean_obj_arg, i: b_lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_string_utf8_set(s: lean_obj_arg, i: b_lean_obj_arg, c: u32) -> lean_obj_res;
}
extern "C" {
    #[link_name = "lean_string_utf8_at_end_rs_extern"]
    pub fn lean_string_utf8_at_end(s: b_lean_obj_arg, i: b_lean_obj_arg) -> u8;
}
extern "C" {
    pub fn lean_string_utf8_extract(
        s: b_lean_obj_arg,
        b: b_lean_obj_arg,
        e: b_lean_obj_arg,
    ) -> lean_obj_res;
}
extern "C" {
    #[link_name = "lean_string_utf8_byte_size_rs_extern"]
    pub fn lean_string_utf8_byte_size(s: b_lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_string_eq_cold(s1: b_lean_obj_arg, s2: b_lean_obj_arg) -> bool;
}
extern "C" {
    #[link_name = "lean_string_eq_rs_extern"]
    pub fn lean_string_eq(s1: b_lean_obj_arg, s2: b_lean_obj_arg) -> bool;
}
extern "C" {
    #[link_name = "lean_string_ne_rs_extern"]
    pub fn lean_string_ne(s1: b_lean_obj_arg, s2: b_lean_obj_arg) -> bool;
}
extern "C" {
    pub fn lean_string_lt(s1: b_lean_obj_arg, s2: b_lean_obj_arg) -> bool;
}
extern "C" {
    #[link_name = "lean_string_dec_eq_rs_extern"]
    pub fn lean_string_dec_eq(s1: b_lean_obj_arg, s2: b_lean_obj_arg) -> u8;
}
extern "C" {
    #[link_name = "lean_string_dec_lt_rs_extern"]
    pub fn lean_string_dec_lt(s1: b_lean_obj_arg, s2: b_lean_obj_arg) -> u8;
}
extern "C" {
    pub fn lean_string_hash(arg1: b_lean_obj_arg) -> u64;
}
extern "C" {
    #[link_name = "lean_mk_thunk_rs_extern"]
    pub fn lean_mk_thunk(c: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    #[link_name = "lean_thunk_pure_rs_extern"]
    pub fn lean_thunk_pure(v: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_thunk_get_core(t: *mut lean_object) -> *mut lean_object;
}
extern "C" {
    #[link_name = "lean_thunk_get_rs_extern"]
    pub fn lean_thunk_get(t: b_lean_obj_arg) -> b_lean_obj_res;
}
extern "C" {
    #[link_name = "lean_thunk_get_own_rs_extern"]
    pub fn lean_thunk_get_own(t: b_lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_init_task_manager();
}
extern "C" {
    pub fn lean_init_task_manager_using(num_workers: ::core::ffi::c_uint);
}
extern "C" {
    pub fn lean_finalize_task_manager();
}
extern "C" {
    pub fn lean_task_spawn_core(
        c: lean_obj_arg,
        prio: ::core::ffi::c_uint,
        keep_alive: bool,
    ) -> lean_obj_res;
}
extern "C" {
    #[link_name = "lean_task_spawn_rs_extern"]
    pub fn lean_task_spawn(c: lean_obj_arg, prio: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_task_pure(a: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_task_bind_core(
        x: lean_obj_arg,
        f: lean_obj_arg,
        prio: ::core::ffi::c_uint,
        keep_alive: bool,
    ) -> lean_obj_res;
}
extern "C" {
    #[link_name = "lean_task_bind_rs_extern"]
    pub fn lean_task_bind(x: lean_obj_arg, f: lean_obj_arg, prio: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_task_map_core(
        f: lean_obj_arg,
        t: lean_obj_arg,
        prio: ::core::ffi::c_uint,
        keep_alive: bool,
    ) -> lean_obj_res;
}
extern "C" {
    #[link_name = "lean_task_map_rs_extern"]
    pub fn lean_task_map(f: lean_obj_arg, t: lean_obj_arg, prio: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_task_get(t: b_lean_obj_arg) -> b_lean_obj_res;
}
extern "C" {
    #[link_name = "lean_task_get_own_rs_extern"]
    pub fn lean_task_get_own(t: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_io_check_canceled_core() -> bool;
}
extern "C" {
    pub fn lean_io_cancel_core(t: b_lean_obj_arg);
}
extern "C" {
    pub fn lean_io_has_finished_core(t: b_lean_obj_arg) -> bool;
}
extern "C" {
    pub fn lean_io_wait_any_core(task_list: b_lean_obj_arg) -> b_lean_obj_res;
}
extern "C" {
    #[link_name = "lean_alloc_external_rs_extern"]
    pub fn lean_alloc_external(
        cls: *mut lean_external_class,
        data: *mut ::core::ffi::c_void,
    ) -> *mut lean_object;
}
extern "C" {
    #[link_name = "lean_get_external_class_rs_extern"]
    pub fn lean_get_external_class(o: *mut lean_object) -> *mut lean_external_class;
}
extern "C" {
    #[link_name = "lean_get_external_data_rs_extern"]
    pub fn lean_get_external_data(o: *mut lean_object) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn lean_nat_big_succ(a: *mut lean_object) -> *mut lean_object;
}
extern "C" {
    pub fn lean_nat_big_add(a1: *mut lean_object, a2: *mut lean_object) -> *mut lean_object;
}
extern "C" {
    pub fn lean_nat_big_sub(a1: *mut lean_object, a2: *mut lean_object) -> *mut lean_object;
}
extern "C" {
    pub fn lean_nat_big_mul(a1: *mut lean_object, a2: *mut lean_object) -> *mut lean_object;
}
extern "C" {
    pub fn lean_nat_overflow_mul(a1: usize, a2: usize) -> *mut lean_object;
}
extern "C" {
    pub fn lean_nat_big_div(a1: *mut lean_object, a2: *mut lean_object) -> *mut lean_object;
}
extern "C" {
    pub fn lean_nat_big_mod(a1: *mut lean_object, a2: *mut lean_object) -> *mut lean_object;
}
extern "C" {
    pub fn lean_nat_big_eq(a1: *mut lean_object, a2: *mut lean_object) -> bool;
}
extern "C" {
    pub fn lean_nat_big_le(a1: *mut lean_object, a2: *mut lean_object) -> bool;
}
extern "C" {
    pub fn lean_nat_big_lt(a1: *mut lean_object, a2: *mut lean_object) -> bool;
}
extern "C" {
    pub fn lean_nat_big_land(a1: *mut lean_object, a2: *mut lean_object) -> *mut lean_object;
}
extern "C" {
    pub fn lean_nat_big_lor(a1: *mut lean_object, a2: *mut lean_object) -> *mut lean_object;
}
extern "C" {
    pub fn lean_nat_big_xor(a1: *mut lean_object, a2: *mut lean_object) -> *mut lean_object;
}
extern "C" {
    pub fn lean_cstr_to_nat(n: *const ::core::ffi::c_char) -> lean_obj_res;
}
extern "C" {
    pub fn lean_big_usize_to_nat(n: usize) -> lean_obj_res;
}
extern "C" {
    pub fn lean_big_uint64_to_nat(n: u64) -> lean_obj_res;
}
extern "C" {
    #[link_name = "lean_usize_to_nat_rs_extern"]
    pub fn lean_usize_to_nat(n: usize) -> lean_obj_res;
}
extern "C" {
    #[link_name = "lean_unsigned_to_nat_rs_extern"]
    pub fn lean_unsigned_to_nat(n: ::core::ffi::c_uint) -> lean_obj_res;
}
extern "C" {
    #[link_name = "lean_uint64_to_nat_rs_extern"]
    pub fn lean_uint64_to_nat(n: u64) -> lean_obj_res;
}
extern "C" {
    #[link_name = "lean_nat_succ_rs_extern"]
    pub fn lean_nat_succ(a: b_lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    #[link_name = "lean_nat_add_rs_extern"]
    pub fn lean_nat_add(a1: b_lean_obj_arg, a2: b_lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    #[link_name = "lean_nat_sub_rs_extern"]
    pub fn lean_nat_sub(a1: b_lean_obj_arg, a2: b_lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    #[link_name = "lean_nat_mul_rs_extern"]
    pub fn lean_nat_mul(a1: b_lean_obj_arg, a2: b_lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    #[link_name = "lean_nat_div_rs_extern"]
    pub fn lean_nat_div(a1: b_lean_obj_arg, a2: b_lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    #[link_name = "lean_nat_mod_rs_extern"]
    pub fn lean_nat_mod(a1: b_lean_obj_arg, a2: b_lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    #[link_name = "lean_nat_eq_rs_extern"]
    pub fn lean_nat_eq(a1: b_lean_obj_arg, a2: b_lean_obj_arg) -> bool;
}
extern "C" {
    #[link_name = "lean_nat_dec_eq_rs_extern"]
    pub fn lean_nat_dec_eq(a1: b_lean_obj_arg, a2: b_lean_obj_arg) -> u8;
}
extern "C" {
    #[link_name = "lean_nat_ne_rs_extern"]
    pub fn lean_nat_ne(a1: b_lean_obj_arg, a2: b_lean_obj_arg) -> bool;
}
extern "C" {
    #[link_name = "lean_nat_le_rs_extern"]
    pub fn lean_nat_le(a1: b_lean_obj_arg, a2: b_lean_obj_arg) -> bool;
}
extern "C" {
    #[link_name = "lean_nat_dec_le_rs_extern"]
    pub fn lean_nat_dec_le(a1: b_lean_obj_arg, a2: b_lean_obj_arg) -> u8;
}
extern "C" {
    #[link_name = "lean_nat_lt_rs_extern"]
    pub fn lean_nat_lt(a1: b_lean_obj_arg, a2: b_lean_obj_arg) -> bool;
}
extern "C" {
    #[link_name = "lean_nat_dec_lt_rs_extern"]
    pub fn lean_nat_dec_lt(a1: b_lean_obj_arg, a2: b_lean_obj_arg) -> u8;
}
extern "C" {
    #[link_name = "lean_nat_land_rs_extern"]
    pub fn lean_nat_land(a1: b_lean_obj_arg, a2: b_lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    #[link_name = "lean_nat_lor_rs_extern"]
    pub fn lean_nat_lor(a1: b_lean_obj_arg, a2: b_lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    #[link_name = "lean_nat_lxor_rs_extern"]
    pub fn lean_nat_lxor(a1: b_lean_obj_arg, a2: b_lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_nat_shiftl(a1: b_lean_obj_arg, a2: b_lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_nat_shiftr(a1: b_lean_obj_arg, a2: b_lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_nat_pow(a1: b_lean_obj_arg, a2: b_lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_nat_gcd(a1: b_lean_obj_arg, a2: b_lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_nat_log2(a: b_lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_int_big_neg(a: *mut lean_object) -> *mut lean_object;
}
extern "C" {
    pub fn lean_int_big_add(a1: *mut lean_object, a2: *mut lean_object) -> *mut lean_object;
}
extern "C" {
    pub fn lean_int_big_sub(a1: *mut lean_object, a2: *mut lean_object) -> *mut lean_object;
}
extern "C" {
    pub fn lean_int_big_mul(a1: *mut lean_object, a2: *mut lean_object) -> *mut lean_object;
}
extern "C" {
    pub fn lean_int_big_div(a1: *mut lean_object, a2: *mut lean_object) -> *mut lean_object;
}
extern "C" {
    pub fn lean_int_big_mod(a1: *mut lean_object, a2: *mut lean_object) -> *mut lean_object;
}
extern "C" {
    pub fn lean_int_big_eq(a1: *mut lean_object, a2: *mut lean_object) -> bool;
}
extern "C" {
    pub fn lean_int_big_le(a1: *mut lean_object, a2: *mut lean_object) -> bool;
}
extern "C" {
    pub fn lean_int_big_lt(a1: *mut lean_object, a2: *mut lean_object) -> bool;
}
extern "C" {
    pub fn lean_int_big_nonneg(a: *mut lean_object) -> bool;
}
extern "C" {
    pub fn lean_cstr_to_int(n: *const ::core::ffi::c_char) -> *mut lean_object;
}
extern "C" {
    pub fn lean_big_int_to_int(n: ::core::ffi::c_int) -> *mut lean_object;
}
extern "C" {
    pub fn lean_big_size_t_to_int(n: usize) -> *mut lean_object;
}
extern "C" {
    pub fn lean_big_int64_to_int(n: i64) -> *mut lean_object;
}
extern "C" {
    #[link_name = "lean_int_to_int_rs_extern"]
    pub fn lean_int_to_int(n: ::core::ffi::c_int) -> lean_obj_res;
}
extern "C" {
    #[link_name = "lean_int64_to_int_rs_extern"]
    pub fn lean_int64_to_int(n: i64) -> lean_obj_res;
}
extern "C" {
    #[link_name = "lean_scalar_to_int64_rs_extern"]
    pub fn lean_scalar_to_int64(a: b_lean_obj_arg) -> i64;
}
extern "C" {
    #[link_name = "lean_scalar_to_int_rs_extern"]
    pub fn lean_scalar_to_int(a: b_lean_obj_arg) -> ::core::ffi::c_int;
}
extern "C" {
    #[link_name = "lean_nat_to_int_rs_extern"]
    pub fn lean_nat_to_int(a: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    #[link_name = "lean_int_neg_rs_extern"]
    pub fn lean_int_neg(a: b_lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    #[link_name = "lean_int_neg_succ_of_nat_rs_extern"]
    pub fn lean_int_neg_succ_of_nat(a: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    #[link_name = "lean_int_add_rs_extern"]
    pub fn lean_int_add(a1: b_lean_obj_arg, a2: b_lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    #[link_name = "lean_int_sub_rs_extern"]
    pub fn lean_int_sub(a1: b_lean_obj_arg, a2: b_lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    #[link_name = "lean_int_mul_rs_extern"]
    pub fn lean_int_mul(a1: b_lean_obj_arg, a2: b_lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    #[link_name = "lean_int_div_rs_extern"]
    pub fn lean_int_div(a1: b_lean_obj_arg, a2: b_lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    #[link_name = "lean_int_mod_rs_extern"]
    pub fn lean_int_mod(a1: b_lean_obj_arg, a2: b_lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    #[link_name = "lean_int_eq_rs_extern"]
    pub fn lean_int_eq(a1: b_lean_obj_arg, a2: b_lean_obj_arg) -> bool;
}
extern "C" {
    #[link_name = "lean_int_ne_rs_extern"]
    pub fn lean_int_ne(a1: b_lean_obj_arg, a2: b_lean_obj_arg) -> bool;
}
extern "C" {
    #[link_name = "lean_int_le_rs_extern"]
    pub fn lean_int_le(a1: b_lean_obj_arg, a2: b_lean_obj_arg) -> bool;
}
extern "C" {
    #[link_name = "lean_int_lt_rs_extern"]
    pub fn lean_int_lt(a1: b_lean_obj_arg, a2: b_lean_obj_arg) -> bool;
}
extern "C" {
    pub fn lean_big_int_to_nat(a: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    #[link_name = "lean_int_to_nat_rs_extern"]
    pub fn lean_int_to_nat(a: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    #[link_name = "lean_nat_abs_rs_extern"]
    pub fn lean_nat_abs(i: b_lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    #[link_name = "lean_int_dec_eq_rs_extern"]
    pub fn lean_int_dec_eq(a1: b_lean_obj_arg, a2: b_lean_obj_arg) -> u8;
}
extern "C" {
    #[link_name = "lean_int_dec_le_rs_extern"]
    pub fn lean_int_dec_le(a1: b_lean_obj_arg, a2: b_lean_obj_arg) -> u8;
}
extern "C" {
    #[link_name = "lean_int_dec_lt_rs_extern"]
    pub fn lean_int_dec_lt(a1: b_lean_obj_arg, a2: b_lean_obj_arg) -> u8;
}
extern "C" {
    #[link_name = "lean_int_dec_nonneg_rs_extern"]
    pub fn lean_int_dec_nonneg(a: b_lean_obj_arg) -> u8;
}
extern "C" {
    #[link_name = "lean_bool_to_uint64_rs_extern"]
    pub fn lean_bool_to_uint64(a: u8) -> u64;
}
extern "C" {
    pub fn lean_uint8_of_big_nat(a: b_lean_obj_arg) -> u8;
}
extern "C" {
    #[link_name = "lean_uint8_of_nat_rs_extern"]
    pub fn lean_uint8_of_nat(a: b_lean_obj_arg) -> u8;
}
extern "C" {
    #[link_name = "lean_uint8_of_nat_mk_rs_extern"]
    pub fn lean_uint8_of_nat_mk(a: lean_obj_arg) -> u8;
}
extern "C" {
    #[link_name = "lean_uint8_to_nat_rs_extern"]
    pub fn lean_uint8_to_nat(a: u8) -> lean_obj_res;
}
extern "C" {
    #[link_name = "lean_uint8_add_rs_extern"]
    pub fn lean_uint8_add(a1: u8, a2: u8) -> u8;
}
extern "C" {
    #[link_name = "lean_uint8_sub_rs_extern"]
    pub fn lean_uint8_sub(a1: u8, a2: u8) -> u8;
}
extern "C" {
    #[link_name = "lean_uint8_mul_rs_extern"]
    pub fn lean_uint8_mul(a1: u8, a2: u8) -> u8;
}
extern "C" {
    #[link_name = "lean_uint8_div_rs_extern"]
    pub fn lean_uint8_div(a1: u8, a2: u8) -> u8;
}
extern "C" {
    #[link_name = "lean_uint8_mod_rs_extern"]
    pub fn lean_uint8_mod(a1: u8, a2: u8) -> u8;
}
extern "C" {
    #[link_name = "lean_uint8_land_rs_extern"]
    pub fn lean_uint8_land(a: u8, b: u8) -> u8;
}
extern "C" {
    #[link_name = "lean_uint8_lor_rs_extern"]
    pub fn lean_uint8_lor(a: u8, b: u8) -> u8;
}
extern "C" {
    #[link_name = "lean_uint8_xor_rs_extern"]
    pub fn lean_uint8_xor(a: u8, b: u8) -> u8;
}
extern "C" {
    #[link_name = "lean_uint8_shift_left_rs_extern"]
    pub fn lean_uint8_shift_left(a: u8, b: u8) -> u8;
}
extern "C" {
    #[link_name = "lean_uint8_shift_right_rs_extern"]
    pub fn lean_uint8_shift_right(a: u8, b: u8) -> u8;
}
extern "C" {
    #[link_name = "lean_uint8_complement_rs_extern"]
    pub fn lean_uint8_complement(a: u8) -> u8;
}
extern "C" {
    #[link_name = "lean_uint8_modn_rs_extern"]
    pub fn lean_uint8_modn(a1: u8, a2: b_lean_obj_arg) -> u8;
}
extern "C" {
    #[link_name = "lean_uint8_log2_rs_extern"]
    pub fn lean_uint8_log2(a: u8) -> u8;
}
extern "C" {
    #[link_name = "lean_uint8_dec_eq_rs_extern"]
    pub fn lean_uint8_dec_eq(a1: u8, a2: u8) -> u8;
}
extern "C" {
    #[link_name = "lean_uint8_dec_lt_rs_extern"]
    pub fn lean_uint8_dec_lt(a1: u8, a2: u8) -> u8;
}
extern "C" {
    #[link_name = "lean_uint8_dec_le_rs_extern"]
    pub fn lean_uint8_dec_le(a1: u8, a2: u8) -> u8;
}
extern "C" {
    #[link_name = "lean_uint8_to_uint16_rs_extern"]
    pub fn lean_uint8_to_uint16(a: u8) -> u16;
}
extern "C" {
    #[link_name = "lean_uint8_to_uint32_rs_extern"]
    pub fn lean_uint8_to_uint32(a: u8) -> u32;
}
extern "C" {
    #[link_name = "lean_uint8_to_uint64_rs_extern"]
    pub fn lean_uint8_to_uint64(a: u8) -> u64;
}
extern "C" {
    pub fn lean_uint16_of_big_nat(a: b_lean_obj_arg) -> u16;
}
extern "C" {
    #[link_name = "lean_uint16_of_nat_rs_extern"]
    pub fn lean_uint16_of_nat(a: b_lean_obj_arg) -> u16;
}
extern "C" {
    #[link_name = "lean_uint16_of_nat_mk_rs_extern"]
    pub fn lean_uint16_of_nat_mk(a: lean_obj_arg) -> u16;
}
extern "C" {
    #[link_name = "lean_uint16_to_nat_rs_extern"]
    pub fn lean_uint16_to_nat(a: u16) -> lean_obj_res;
}
extern "C" {
    #[link_name = "lean_uint16_add_rs_extern"]
    pub fn lean_uint16_add(a1: u16, a2: u16) -> u16;
}
extern "C" {
    #[link_name = "lean_uint16_sub_rs_extern"]
    pub fn lean_uint16_sub(a1: u16, a2: u16) -> u16;
}
extern "C" {
    #[link_name = "lean_uint16_mul_rs_extern"]
    pub fn lean_uint16_mul(a1: u16, a2: u16) -> u16;
}
extern "C" {
    #[link_name = "lean_uint16_div_rs_extern"]
    pub fn lean_uint16_div(a1: u16, a2: u16) -> u16;
}
extern "C" {
    #[link_name = "lean_uint16_mod_rs_extern"]
    pub fn lean_uint16_mod(a1: u16, a2: u16) -> u16;
}
extern "C" {
    #[link_name = "lean_uint16_land_rs_extern"]
    pub fn lean_uint16_land(a: u16, b: u16) -> u16;
}
extern "C" {
    #[link_name = "lean_uint16_lor_rs_extern"]
    pub fn lean_uint16_lor(a: u16, b: u16) -> u16;
}
extern "C" {
    #[link_name = "lean_uint16_xor_rs_extern"]
    pub fn lean_uint16_xor(a: u16, b: u16) -> u16;
}
extern "C" {
    #[link_name = "lean_uint16_shift_left_rs_extern"]
    pub fn lean_uint16_shift_left(a: u16, b: u16) -> u16;
}
extern "C" {
    #[link_name = "lean_uint16_shift_right_rs_extern"]
    pub fn lean_uint16_shift_right(a: u16, b: u16) -> u16;
}
extern "C" {
    #[link_name = "lean_uint16_complement_rs_extern"]
    pub fn lean_uint16_complement(a: u16) -> u16;
}
extern "C" {
    #[link_name = "lean_uint16_modn_rs_extern"]
    pub fn lean_uint16_modn(a1: u16, a2: b_lean_obj_arg) -> u16;
}
extern "C" {
    #[link_name = "lean_uint16_log2_rs_extern"]
    pub fn lean_uint16_log2(a: u16) -> u16;
}
extern "C" {
    #[link_name = "lean_uint16_dec_eq_rs_extern"]
    pub fn lean_uint16_dec_eq(a1: u16, a2: u16) -> u8;
}
extern "C" {
    #[link_name = "lean_uint16_dec_lt_rs_extern"]
    pub fn lean_uint16_dec_lt(a1: u16, a2: u16) -> u8;
}
extern "C" {
    #[link_name = "lean_uint16_dec_le_rs_extern"]
    pub fn lean_uint16_dec_le(a1: u16, a2: u16) -> u8;
}
extern "C" {
    #[link_name = "lean_uint16_to_uint8_rs_extern"]
    pub fn lean_uint16_to_uint8(a: u16) -> u8;
}
extern "C" {
    #[link_name = "lean_uint16_to_uint32_rs_extern"]
    pub fn lean_uint16_to_uint32(a: u16) -> u32;
}
extern "C" {
    #[link_name = "lean_uint16_to_uint64_rs_extern"]
    pub fn lean_uint16_to_uint64(a: u16) -> u64;
}
extern "C" {
    pub fn lean_uint32_of_big_nat(a: b_lean_obj_arg) -> u32;
}
extern "C" {
    #[link_name = "lean_uint32_of_nat_rs_extern"]
    pub fn lean_uint32_of_nat(a: b_lean_obj_arg) -> u32;
}
extern "C" {
    #[link_name = "lean_uint32_of_nat_mk_rs_extern"]
    pub fn lean_uint32_of_nat_mk(a: lean_obj_arg) -> u32;
}
extern "C" {
    #[link_name = "lean_uint32_to_nat_rs_extern"]
    pub fn lean_uint32_to_nat(a: u32) -> lean_obj_res;
}
extern "C" {
    #[link_name = "lean_uint32_add_rs_extern"]
    pub fn lean_uint32_add(a1: u32, a2: u32) -> u32;
}
extern "C" {
    #[link_name = "lean_uint32_sub_rs_extern"]
    pub fn lean_uint32_sub(a1: u32, a2: u32) -> u32;
}
extern "C" {
    #[link_name = "lean_uint32_mul_rs_extern"]
    pub fn lean_uint32_mul(a1: u32, a2: u32) -> u32;
}
extern "C" {
    #[link_name = "lean_uint32_div_rs_extern"]
    pub fn lean_uint32_div(a1: u32, a2: u32) -> u32;
}
extern "C" {
    #[link_name = "lean_uint32_mod_rs_extern"]
    pub fn lean_uint32_mod(a1: u32, a2: u32) -> u32;
}
extern "C" {
    #[link_name = "lean_uint32_land_rs_extern"]
    pub fn lean_uint32_land(a: u32, b: u32) -> u32;
}
extern "C" {
    #[link_name = "lean_uint32_lor_rs_extern"]
    pub fn lean_uint32_lor(a: u32, b: u32) -> u32;
}
extern "C" {
    #[link_name = "lean_uint32_xor_rs_extern"]
    pub fn lean_uint32_xor(a: u32, b: u32) -> u32;
}
extern "C" {
    #[link_name = "lean_uint32_shift_left_rs_extern"]
    pub fn lean_uint32_shift_left(a: u32, b: u32) -> u32;
}
extern "C" {
    #[link_name = "lean_uint32_shift_right_rs_extern"]
    pub fn lean_uint32_shift_right(a: u32, b: u32) -> u32;
}
extern "C" {
    #[link_name = "lean_uint32_complement_rs_extern"]
    pub fn lean_uint32_complement(a: u32) -> u32;
}
extern "C" {
    pub fn lean_uint32_big_modn(a1: u32, a2: b_lean_obj_arg) -> u32;
}
extern "C" {
    #[link_name = "lean_uint32_modn_rs_extern"]
    pub fn lean_uint32_modn(a1: u32, a2: b_lean_obj_arg) -> u32;
}
extern "C" {
    #[link_name = "lean_uint32_log2_rs_extern"]
    pub fn lean_uint32_log2(a: u32) -> u32;
}
extern "C" {
    #[link_name = "lean_uint32_dec_eq_rs_extern"]
    pub fn lean_uint32_dec_eq(a1: u32, a2: u32) -> u8;
}
extern "C" {
    #[link_name = "lean_uint32_dec_lt_rs_extern"]
    pub fn lean_uint32_dec_lt(a1: u32, a2: u32) -> u8;
}
extern "C" {
    #[link_name = "lean_uint32_dec_le_rs_extern"]
    pub fn lean_uint32_dec_le(a1: u32, a2: u32) -> u8;
}
extern "C" {
    #[link_name = "lean_uint32_to_uint8_rs_extern"]
    pub fn lean_uint32_to_uint8(a: u32) -> u8;
}
extern "C" {
    #[link_name = "lean_uint32_to_uint16_rs_extern"]
    pub fn lean_uint32_to_uint16(a: u32) -> u16;
}
extern "C" {
    #[link_name = "lean_uint32_to_uint64_rs_extern"]
    pub fn lean_uint32_to_uint64(a: u32) -> u64;
}
extern "C" {
    #[link_name = "lean_uint32_to_usize_rs_extern"]
    pub fn lean_uint32_to_usize(a: u32) -> usize;
}
extern "C" {
    pub fn lean_uint64_of_big_nat(a: b_lean_obj_arg) -> u64;
}
extern "C" {
    #[link_name = "lean_uint64_of_nat_rs_extern"]
    pub fn lean_uint64_of_nat(a: b_lean_obj_arg) -> u64;
}
extern "C" {
    #[link_name = "lean_uint64_of_nat_mk_rs_extern"]
    pub fn lean_uint64_of_nat_mk(a: lean_obj_arg) -> u64;
}
extern "C" {
    #[link_name = "lean_uint64_add_rs_extern"]
    pub fn lean_uint64_add(a1: u64, a2: u64) -> u64;
}
extern "C" {
    #[link_name = "lean_uint64_sub_rs_extern"]
    pub fn lean_uint64_sub(a1: u64, a2: u64) -> u64;
}
extern "C" {
    #[link_name = "lean_uint64_mul_rs_extern"]
    pub fn lean_uint64_mul(a1: u64, a2: u64) -> u64;
}
extern "C" {
    #[link_name = "lean_uint64_div_rs_extern"]
    pub fn lean_uint64_div(a1: u64, a2: u64) -> u64;
}
extern "C" {
    #[link_name = "lean_uint64_mod_rs_extern"]
    pub fn lean_uint64_mod(a1: u64, a2: u64) -> u64;
}
extern "C" {
    #[link_name = "lean_uint64_land_rs_extern"]
    pub fn lean_uint64_land(a: u64, b: u64) -> u64;
}
extern "C" {
    #[link_name = "lean_uint64_lor_rs_extern"]
    pub fn lean_uint64_lor(a: u64, b: u64) -> u64;
}
extern "C" {
    #[link_name = "lean_uint64_xor_rs_extern"]
    pub fn lean_uint64_xor(a: u64, b: u64) -> u64;
}
extern "C" {
    #[link_name = "lean_uint64_shift_left_rs_extern"]
    pub fn lean_uint64_shift_left(a: u64, b: u64) -> u64;
}
extern "C" {
    #[link_name = "lean_uint64_shift_right_rs_extern"]
    pub fn lean_uint64_shift_right(a: u64, b: u64) -> u64;
}
extern "C" {
    #[link_name = "lean_uint64_complement_rs_extern"]
    pub fn lean_uint64_complement(a: u64) -> u64;
}
extern "C" {
    pub fn lean_uint64_big_modn(a1: u64, a2: b_lean_obj_arg) -> u64;
}
extern "C" {
    #[link_name = "lean_uint64_modn_rs_extern"]
    pub fn lean_uint64_modn(a1: u64, a2: b_lean_obj_arg) -> u64;
}
extern "C" {
    #[link_name = "lean_uint64_log2_rs_extern"]
    pub fn lean_uint64_log2(a: u64) -> u64;
}
extern "C" {
    #[link_name = "lean_uint64_dec_eq_rs_extern"]
    pub fn lean_uint64_dec_eq(a1: u64, a2: u64) -> u8;
}
extern "C" {
    #[link_name = "lean_uint64_dec_lt_rs_extern"]
    pub fn lean_uint64_dec_lt(a1: u64, a2: u64) -> u8;
}
extern "C" {
    #[link_name = "lean_uint64_dec_le_rs_extern"]
    pub fn lean_uint64_dec_le(a1: u64, a2: u64) -> u8;
}
extern "C" {
    pub fn lean_uint64_mix_hash(a1: u64, a2: u64) -> u64;
}
extern "C" {
    #[link_name = "lean_uint64_to_uint8_rs_extern"]
    pub fn lean_uint64_to_uint8(a: u64) -> u8;
}
extern "C" {
    #[link_name = "lean_uint64_to_uint16_rs_extern"]
    pub fn lean_uint64_to_uint16(a: u64) -> u16;
}
extern "C" {
    #[link_name = "lean_uint64_to_uint32_rs_extern"]
    pub fn lean_uint64_to_uint32(a: u64) -> u32;
}
extern "C" {
    #[link_name = "lean_uint64_to_usize_rs_extern"]
    pub fn lean_uint64_to_usize(a: u64) -> usize;
}
extern "C" {
    pub fn lean_usize_of_big_nat(a: b_lean_obj_arg) -> usize;
}
extern "C" {
    #[link_name = "lean_usize_of_nat_rs_extern"]
    pub fn lean_usize_of_nat(a: b_lean_obj_arg) -> usize;
}
extern "C" {
    #[link_name = "lean_usize_of_nat_mk_rs_extern"]
    pub fn lean_usize_of_nat_mk(a: lean_obj_arg) -> usize;
}
extern "C" {
    #[link_name = "lean_usize_add_rs_extern"]
    pub fn lean_usize_add(a1: usize, a2: usize) -> usize;
}
extern "C" {
    #[link_name = "lean_usize_sub_rs_extern"]
    pub fn lean_usize_sub(a1: usize, a2: usize) -> usize;
}
extern "C" {
    #[link_name = "lean_usize_mul_rs_extern"]
    pub fn lean_usize_mul(a1: usize, a2: usize) -> usize;
}
extern "C" {
    #[link_name = "lean_usize_div_rs_extern"]
    pub fn lean_usize_div(a1: usize, a2: usize) -> usize;
}
extern "C" {
    #[link_name = "lean_usize_mod_rs_extern"]
    pub fn lean_usize_mod(a1: usize, a2: usize) -> usize;
}
extern "C" {
    #[link_name = "lean_usize_land_rs_extern"]
    pub fn lean_usize_land(a: usize, b: usize) -> usize;
}
extern "C" {
    #[link_name = "lean_usize_lor_rs_extern"]
    pub fn lean_usize_lor(a: usize, b: usize) -> usize;
}
extern "C" {
    #[link_name = "lean_usize_xor_rs_extern"]
    pub fn lean_usize_xor(a: usize, b: usize) -> usize;
}
extern "C" {
    #[link_name = "lean_usize_shift_left_rs_extern"]
    pub fn lean_usize_shift_left(a: usize, b: usize) -> usize;
}
extern "C" {
    #[link_name = "lean_usize_shift_right_rs_extern"]
    pub fn lean_usize_shift_right(a: usize, b: usize) -> usize;
}
extern "C" {
    #[link_name = "lean_usize_complement_rs_extern"]
    pub fn lean_usize_complement(a: usize) -> usize;
}
extern "C" {
    pub fn lean_usize_big_modn(a1: usize, a2: b_lean_obj_arg) -> usize;
}
extern "C" {
    #[link_name = "lean_usize_modn_rs_extern"]
    pub fn lean_usize_modn(a1: usize, a2: b_lean_obj_arg) -> usize;
}
extern "C" {
    #[link_name = "lean_usize_log2_rs_extern"]
    pub fn lean_usize_log2(a: usize) -> usize;
}
extern "C" {
    #[link_name = "lean_usize_dec_eq_rs_extern"]
    pub fn lean_usize_dec_eq(a1: usize, a2: usize) -> u8;
}
extern "C" {
    #[link_name = "lean_usize_dec_lt_rs_extern"]
    pub fn lean_usize_dec_lt(a1: usize, a2: usize) -> u8;
}
extern "C" {
    #[link_name = "lean_usize_dec_le_rs_extern"]
    pub fn lean_usize_dec_le(a1: usize, a2: usize) -> u8;
}
extern "C" {
    #[link_name = "lean_usize_to_uint32_rs_extern"]
    pub fn lean_usize_to_uint32(a: usize) -> u32;
}
extern "C" {
    #[link_name = "lean_usize_to_uint64_rs_extern"]
    pub fn lean_usize_to_uint64(a: usize) -> u64;
}
extern "C" {
    pub fn lean_float_to_string(a: f64) -> lean_obj_res;
}
extern "C" {
    pub fn lean_float_scaleb(a: f64, b: b_lean_obj_arg) -> f64;
}
extern "C" {
    pub fn lean_float_isnan(a: f64) -> u8;
}
extern "C" {
    pub fn lean_float_isfinite(a: f64) -> u8;
}
extern "C" {
    pub fn lean_float_isinf(a: f64) -> u8;
}
extern "C" {
    pub fn lean_float_frexp(a: f64) -> lean_obj_res;
}
extern "C" {
    #[link_name = "lean_box_uint32_rs_extern"]
    pub fn lean_box_uint32(v: u32) -> lean_obj_res;
}
extern "C" {
    #[link_name = "lean_unbox_uint32_rs_extern"]
    pub fn lean_unbox_uint32(o: b_lean_obj_arg) -> ::core::ffi::c_uint;
}
extern "C" {
    #[link_name = "lean_box_uint64_rs_extern"]
    pub fn lean_box_uint64(v: u64) -> lean_obj_res;
}
extern "C" {
    #[link_name = "lean_unbox_uint64_rs_extern"]
    pub fn lean_unbox_uint64(o: b_lean_obj_arg) -> u64;
}
extern "C" {
    #[link_name = "lean_box_usize_rs_extern"]
    pub fn lean_box_usize(v: usize) -> lean_obj_res;
}
extern "C" {
    #[link_name = "lean_unbox_usize_rs_extern"]
    pub fn lean_unbox_usize(o: b_lean_obj_arg) -> usize;
}
extern "C" {
    #[link_name = "lean_box_float_rs_extern"]
    pub fn lean_box_float(v: f64) -> lean_obj_res;
}
extern "C" {
    #[link_name = "lean_unbox_float_rs_extern"]
    pub fn lean_unbox_float(o: b_lean_obj_arg) -> f64;
}
extern "C" {
    pub fn lean_dbg_trace(s: lean_obj_arg, fn_: lean_obj_arg) -> *mut lean_object;
}
extern "C" {
    pub fn lean_dbg_sleep(ms: u32, fn_: lean_obj_arg) -> *mut lean_object;
}
extern "C" {
    pub fn lean_dbg_trace_if_shared(s: lean_obj_arg, a: lean_obj_arg) -> *mut lean_object;
}
extern "C" {
    pub fn lean_decode_io_error(errnum: ::core::ffi::c_int, fname: b_lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    #[link_name = "lean_io_mk_world_rs_extern"]
    pub fn lean_io_mk_world() -> lean_obj_res;
}
extern "C" {
    #[link_name = "lean_io_result_is_ok_rs_extern"]
    pub fn lean_io_result_is_ok(r: b_lean_obj_arg) -> bool;
}
extern "C" {
    #[link_name = "lean_io_result_is_error_rs_extern"]
    pub fn lean_io_result_is_error(r: b_lean_obj_arg) -> bool;
}
extern "C" {
    #[link_name = "lean_io_result_get_value_rs_extern"]
    pub fn lean_io_result_get_value(r: b_lean_obj_arg) -> b_lean_obj_res;
}
extern "C" {
    #[link_name = "lean_io_result_get_error_rs_extern"]
    pub fn lean_io_result_get_error(r: b_lean_obj_arg) -> b_lean_obj_res;
}
extern "C" {
    pub fn lean_io_result_show_error(r: b_lean_obj_arg);
}
extern "C" {
    pub fn lean_io_mark_end_initialization();
}
extern "C" {
    #[link_name = "lean_io_result_mk_ok_rs_extern"]
    pub fn lean_io_result_mk_ok(a: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    #[link_name = "lean_io_result_mk_error_rs_extern"]
    pub fn lean_io_result_mk_error(e: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_mk_io_error_already_exists(arg1: u32, arg2: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_mk_io_error_already_exists_file(
        arg1: lean_obj_arg,
        arg2: u32,
        arg3: lean_obj_arg,
    ) -> lean_obj_res;
}
extern "C" {
    pub fn lean_mk_io_error_eof(arg1: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_mk_io_error_hardware_fault(arg1: u32, arg2: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_mk_io_error_illegal_operation(arg1: u32, arg2: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_mk_io_error_inappropriate_type(arg1: u32, arg2: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_mk_io_error_inappropriate_type_file(
        arg1: lean_obj_arg,
        arg2: u32,
        arg3: lean_obj_arg,
    ) -> lean_obj_res;
}
extern "C" {
    pub fn lean_mk_io_error_interrupted(
        arg1: lean_obj_arg,
        arg2: u32,
        arg3: lean_obj_arg,
    ) -> lean_obj_res;
}
extern "C" {
    pub fn lean_mk_io_error_invalid_argument(arg1: u32, arg2: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_mk_io_error_invalid_argument_file(
        arg1: lean_obj_arg,
        arg2: u32,
        arg3: lean_obj_arg,
    ) -> lean_obj_res;
}
extern "C" {
    pub fn lean_mk_io_error_no_file_or_directory(
        arg1: lean_obj_arg,
        arg2: u32,
        arg3: lean_obj_arg,
    ) -> lean_obj_res;
}
extern "C" {
    pub fn lean_mk_io_error_no_such_thing(arg1: u32, arg2: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_mk_io_error_no_such_thing_file(
        arg1: lean_obj_arg,
        arg2: u32,
        arg3: lean_obj_arg,
    ) -> lean_obj_res;
}
extern "C" {
    pub fn lean_mk_io_error_other_error(arg1: u32, arg2: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_mk_io_error_permission_denied(arg1: u32, arg2: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_mk_io_error_permission_denied_file(
        arg1: lean_obj_arg,
        arg2: u32,
        arg3: lean_obj_arg,
    ) -> lean_obj_res;
}
extern "C" {
    pub fn lean_mk_io_error_protocol_error(arg1: u32, arg2: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_mk_io_error_resource_busy(arg1: u32, arg2: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_mk_io_error_resource_exhausted(arg1: u32, arg2: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_mk_io_error_resource_exhausted_file(
        arg1: lean_obj_arg,
        arg2: u32,
        arg3: lean_obj_arg,
    ) -> lean_obj_res;
}
extern "C" {
    pub fn lean_mk_io_error_resource_vanished(arg1: u32, arg2: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_mk_io_error_time_expired(arg1: u32, arg2: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_mk_io_error_unsatisfied_constraints(arg1: u32, arg2: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_mk_io_error_unsupported_operation(arg1: u32, arg2: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_mk_io_user_error(str_: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_st_mk_ref(arg1: lean_obj_arg, arg2: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_st_ref_get(arg1: b_lean_obj_arg, arg2: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_st_ref_set(
        arg1: b_lean_obj_arg,
        arg2: lean_obj_arg,
        arg3: lean_obj_arg,
    ) -> lean_obj_res;
}
extern "C" {
    pub fn lean_st_ref_reset(arg1: b_lean_obj_arg, arg2: lean_obj_arg) -> lean_obj_res;
}
extern "C" {
    pub fn lean_st_ref_swap(
        arg1: b_lean_obj_arg,
        arg2: lean_obj_arg,
        arg3: lean_obj_arg,
    ) -> lean_obj_res;
}
extern "C" {
    #[link_name = "lean_ptr_addr_rs_extern"]
    pub fn lean_ptr_addr(a: b_lean_obj_arg) -> usize;
}
extern "C" {
    pub fn lean_name_eq(n1: b_lean_obj_arg, n2: b_lean_obj_arg) -> u8;
}
extern "C" {
    #[link_name = "lean_name_hash_ptr_rs_extern"]
    pub fn lean_name_hash_ptr(n: b_lean_obj_arg) -> u64;
}
extern "C" {
    #[link_name = "lean_name_hash_rs_extern"]
    pub fn lean_name_hash(n: b_lean_obj_arg) -> u64;
}
extern "C" {
    #[link_name = "lean_float_to_uint8_rs_extern"]
    pub fn lean_float_to_uint8(a: f64) -> u8;
}
extern "C" {
    #[link_name = "lean_float_to_uint16_rs_extern"]
    pub fn lean_float_to_uint16(a: f64) -> u16;
}
extern "C" {
    #[link_name = "lean_float_to_uint32_rs_extern"]
    pub fn lean_float_to_uint32(a: f64) -> u32;
}
extern "C" {
    #[link_name = "lean_float_to_uint64_rs_extern"]
    pub fn lean_float_to_uint64(a: f64) -> u64;
}
extern "C" {
    #[link_name = "lean_float_to_usize_rs_extern"]
    pub fn lean_float_to_usize(a: f64) -> usize;
}
extern "C" {
    #[link_name = "lean_float_add_rs_extern"]
    pub fn lean_float_add(a: f64, b: f64) -> f64;
}
extern "C" {
    #[link_name = "lean_float_sub_rs_extern"]
    pub fn lean_float_sub(a: f64, b: f64) -> f64;
}
extern "C" {
    #[link_name = "lean_float_mul_rs_extern"]
    pub fn lean_float_mul(a: f64, b: f64) -> f64;
}
extern "C" {
    #[link_name = "lean_float_div_rs_extern"]
    pub fn lean_float_div(a: f64, b: f64) -> f64;
}
extern "C" {
    #[link_name = "lean_float_negate_rs_extern"]
    pub fn lean_float_negate(a: f64) -> f64;
}
extern "C" {
    #[link_name = "lean_float_beq_rs_extern"]
    pub fn lean_float_beq(a: f64, b: f64) -> u8;
}
extern "C" {
    #[link_name = "lean_float_decLe_rs_extern"]
    pub fn lean_float_decLe(a: f64, b: f64) -> u8;
}
extern "C" {
    #[link_name = "lean_float_decLt_rs_extern"]
    pub fn lean_float_decLt(a: f64, b: f64) -> u8;
}
extern "C" {
    #[link_name = "lean_uint64_to_float_rs_extern"]
    pub fn lean_uint64_to_float(a: u64) -> f64;
}
extern "C" {
    #[link_name = "lean_data_hashmap_mk_idx_rs_extern"]
    pub fn lean_data_hashmap_mk_idx(sz: *mut lean_object, hash: u64) -> usize;
}
pub type __builtin_va_list = *mut ::core::ffi::c_char;
